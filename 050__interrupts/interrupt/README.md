# Hello Interrupt Module

The source was tested compiled and running on 5.4.75.  


## Usage

```
$ make
$ sudo insmod interrupt.ko

// see interrupt handler registered for interrupt 11
$ cat /proc/interrupts | grep lothar
      11:          0          0          0          0          0          0          0          0  IR-IO-APIC   11-edge      lothars_device

// start event
$ sudo cat /dev/lothars_device
    Message from syslogd@debian at Jan 28 22:53:07 ...
    kernel:do_IRQ: 2.56 No irq handler for vector

$ sudo rmmod interrupt

$ dmesg | tail
    Jan 28 22:52:55 debian kernel: init_hello_interrupt() initializing...
    Jan 28 22:52:55 debian kernel: init_hello_interrupt() major = 244, minor = 123
    Jan 28 22:53:07 debian kernel: hello_interrupt_read()
    Jan 28 22:53:07 debian kernel: do_IRQ: 2.56 No irq handler for vector
    Jan 28 22:53:37 debian kernel: cleanup_hello_interrupt() READY.

```

NB: the ``vector_irq[]`` is not available right away. Thus this part is commented out in the kernel due to compile it on the continuous integration (CI) system. In order to experiment with interrupts but without hardware, i.e. to misuse the IRQ 0x80, follow the comment from stack overflow:  

__This used to work on older kernel versions, but fails on later versions. The reason is that the generic IRQ handler ``do_IRQ()`` has been changed for better IRQ handling performance. Instead of using the irq_to_``desc()`` function to get the IRQ descriptor, it reads it from the per-CPU data. The descriptor is put there during the physical device initialization. Since this pseudo device driver don't have a physical device, ``do_IRQ()`` don't find it there and returns with an error. If we want to simulate IRQ using software interrupt, we must first write the IRQ descriptor to the per-CPU data. Unfortunately, the symbol vector_irq, the array of the IRQ descriptors in the per-CPU data, is not exported to kernel modules during kernel compilation. The only way to change it, is to recompile the whole kernel. If you think it worth the effort, you can add the line:__  

```
    EXPORT_SYMBOL (vector_irq);
```

__in the file: arch/x86/kernel/irq.c right after all the include lines.__  

https://stackoverflow.com/questions/57391628/error-while-raising-interrupt-11-with-inline-asm-into-kernel-module


## Notes

These is the process that will be done by the kernel when an interrupt arrives.  

1. Upon receiving an interrupt, the interrupt controller sends a signal to the processor.  
2. The processor detects this signal and interrupts its current execution to handle the interrupt.  
3. The processor can then notify the operating system that an interrupt has occurred, and the operating system can handle the interrupt appropriately.  

Interrupt handling is amongst the most sensitive tasks performed by the kernel and it must satisfy the following:

 * Hardware devices generate interrupts asynchronously (with respect to the processor clock). That means interrupts can come anytime.
 * Because interrupts can come anytime, the kernel might be handling one of them while another one (of a different type) occurs.
 * Some critical regions exist inside the kernel code where interrupts must be disabled. Such critical regions must be limited as much as possible.

Exceptions are often discussed at the same time as interrupts. Unlike interrupts, exceptions occur synchronously with respect to the processor clock; they are often called synchronous interrupts.   

 * Interrupts: asynchronous interrupts generated by hardware.  

    * Maskable – All Interrupt Requests (IRQs) issued by I/O devices give rise to maskable interrupts. A maskable interrupt can be in two states: masked or unmasked; a masked interrupt is ignored by the control unit as long as it remains masked.  

    * Nonmaskable – Only a few critical events (such as hardware failures) give rise to nonmaskable interrupts. Nonmaskable interrupts are always recognized by the CPU.  

 * Exceptions: synchronous interrupts generated by the processor.  

    * Falts - Like Divide by zero, Page Fault, Segmentation Fault.  

    * Traps - Reported immediately following the execution of the trapping instruction. Like Breakpoints.  

    * Aborts - Aborts are used to report severe errors, such as hardware failures and invalid or inconsistent values in system tables.  

In Linux, interrupt handlers are normal C functions, which match a specific prototype and thus enables the kernel to pass the handler information in a standard way. What differentiates interrupt handlers from other kernel functions is that the kernel invokes them in response to interrupts and that they run in a **special context** called **interrupt context**. This special context is occasionally called **atomic context** because code executing in this context is unable to block.  

Kernel code running in **process context is preemptible**. An **interrupt context, however always runs to completion and is not preemptible**.

Code executing from interrupt context cannot do the following:

 * Go to sleep or relinquish the processor
 * Acquire a mutex
 * Perform time-consuming tasks
 * Access user space virtual memory


Based on our idea, ISR or Interrupt Handler should be executed very quickly and it should not run for more time (it should not perform time-consuming tasks). What if, I want to do a huge amount of work upon receiving interrupts?  

To eliminate that problem, the processing of interrupts is split into two parts, or halves:  

 * **Top halves** - The interrupt handler is the top half.  

 * **Bottom halves** - The bottom half is used to process data, letting the top half to deal with new incoming interrupts. Interrupts are enabled when a bottom half runs.  


There are **4 bottom half mechanisms** are available in Linux:

 * Workqueue
 * Threaded IRQs
 * Softirq
 * Tasklets

---

## References:

 * Linux Kernel Module Programming Guide, Peter Jay Salzman, 2007-05-18
 * Highly inspired by / many thanks to www.embetronicx.com (2021)
 * https://github.com/Embetronicx/Tutorials/tree/master/Linux/Device_Driver
