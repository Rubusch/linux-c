# Hello Interrupt Module

The source requires x86 (32-bit) toolchain and kernel. The source was tested compiled and running on 5.4.75.  


## Usage

```
$ make
$ sudo insmod interrupt.ko

// see interrupt handler registered for interrupt 11
$ cat /proc/interrupts | grep lothar
      11:          0          0          0          0          0          0          0          0  IR-IO-APIC   11-edge      lothars_device

// start event
$ sudo cat /dev/lothars_device
    Message from syslogd@debian at Jan 28 22:53:07 ...
    kernel:do_IRQ: 2.56 No irq handler for vector

$ sudo rmmod interrupt

$ dmesg | tail
    Jan 28 22:52:55 debian kernel: init_hello_interrupt() initializing...
    Jan 28 22:52:55 debian kernel: init_hello_interrupt() major = 244, minor = 123
    Jan 28 22:53:07 debian kernel: hello_interrupt_read()
    Jan 28 22:53:07 debian kernel: do_IRQ: 2.56 No irq handler for vector
    Jan 28 22:53:37 debian kernel: cleanup_hello_interrupt() READY.

```

NB: the ``vector_irq[]`` is not available right away. Thus this part is
commented out in the kernel due to compile it on the continuous integration
(CI) system. In order to experiment with interrupts but without hardware, i.e.
to misuse the IRQ 0x80, follow the comment from stack overflow:  

__This used to work on older kernel versions, but fails on later versions. The
reason is that the generic IRQ handler ``do_IRQ()`` has been changed for better
IRQ handling performance. Instead of using the irq_to_``desc()`` function to
get the IRQ descriptor, it reads it from the per-CPU data. The descriptor is
put there during the physical device initialization. Since this pseudo device
driver don't have a physical device, ``do_IRQ()`` don't find it there and
returns with an error. If we want to simulate IRQ using software interrupt, we
must first write the IRQ descriptor to the per-CPU data. Unfortunately, the
symbol vector_irq, the array of the IRQ descriptors in the per-CPU data, is not
exported to kernel modules during kernel compilation. The only way to change
it, is to recompile the whole kernel. If you think it worth the effort, you can
add the line:__  

```
    EXPORT_SYMBOL (vector_irq);
```

__in the file: arch/x86/kernel/irq.c right after all the include lines.__  

https://stackoverflow.com/questions/57391628/error-while-raising-interrupt-11-with-inline-asm-into-kernel-module


## Notes

This is the process that will be done by the kernel when an interrupt arrives.  

1. Upon receiving an interrupt, the interrupt controller sends a signal to the
   processor.  
2. The processor detects this signal and interrupts its current execution to
   handle the interrupt.  
3. The processor can then notify the operating system that an interrupt has
   occurred, and the operating system can handle the interrupt appropriately.  

Interrupt handling is amongst the most sensitive tasks performed by the kernel
and it must satisfy the following:

 * Hardware devices generate interrupts asynchronously (with respect to the
   processor clock). That means interrupts can come anytime.
 * Because interrupts can come anytime, the kernel might be handling one of
   them while another one (of a different type) occurs.
 * Some critical regions exist inside the kernel code where interrupts must be
   disabled. Such critical regions must be limited as much as possible.

*Exceptions* are often discussed at the same time as *interrupts*. Unlike
interrupts, exceptions occur _synchronously_ with respect to the processor
clock; they are often called _synchronous interrupts_.   

 * Interrupts: asynchronous interrupts generated by hardware.
    * Maskable – All Interrupt Requests (IRQs) issued by I/O devices give rise
      to maskable interrupts. A maskable interrupt can be in two states: masked
      or unmasked; a masked interrupt is ignored by the control unit as long as
      it remains masked.
    * Nonmaskable – Only a few critical events (such as hardware failures) give
      rise to nonmaskable interrupts. Nonmaskable interrupts are always
      recognized by the CPU.  

 * Exceptions: synchronous interrupts generated by the processor.  
    * Faults - Like Divide by zero, Page Fault, Segmentation Fault.  
    * Traps - Reported immediately following the execution of the trapping
      instruction. Like Breakpoints.  
    * Aborts - Aborts are used to report severe errors, such as hardware
      failures and invalid or inconsistent values in system tables.  

In Linux, interrupt handlers are normal C functions, which match a specific
prototype and thus enables the kernel to pass the handler information in a
standard way. What differentiates interrupt handlers from other kernel
functions is that the kernel invokes them in response to interrupts and that
they run in a **special context** called **interrupt context**. This special
context is occasionally called **atomic context** because code executing in
this context is unable to block.  

Kernel code running in **process context is preemptible**. An **interrupt
context, however always runs to completion and is not preemptible**.

Code executing from interrupt context cannot do the following:
 * Go to sleep or relinquish the processor
 * Acquire a mutex
 * Perform time-consuming tasks
 * Access user space virtual memory


Based on our idea, ISR or Interrupt Handler should be executed very quickly and
it should not run for more time (it should not perform time-consuming tasks).
What if, I want to do a huge amount of work upon receiving interrupts?  

To eliminate that problem, the processing of interrupts is split into two
parts, or halves:  
 * **Top halves** - The interrupt handler is the top half.  
 * **Bottom halves** - The bottom half is used to process data, letting the top
   half to deal with new incoming interrupts. Interrupts are enabled when a
   bottom half runs.  


There are **4 bottom half mechanisms** are available in Linux:

 * Workqueue
 * Threaded IRQs
 * Softirq
 * Tasklets

---

## References:

 * Linux Kernel Module Programming Guide, Peter Jay Salzman, 2007-05-18
 * Highly inspired by / many thanks to www.embetronicx.com (2021)
 * https://github.com/Embetronicx/Tutorials/tree/master/Linux/Device_Driver
